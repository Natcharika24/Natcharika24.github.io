<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Train Tracker | Vivid Nature (Ultra-Fast)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87ceeb;
            font-family: 'Outfit', 'Prompt', sans-serif;
            color: white;
        }

        #overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #10b981;
        }

        h2 {
            margin: 0 0 5px 0;
            color: #10b981;
            font-family: 'Outfit', sans-serif;
            font-size: 1.2rem;
        }

        #footer {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            z-index: 10;
            font-size: 0.8rem;
            color: #222;
            font-family: 'Outfit';
            pointer-events: none;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&family=Prompt:wght@400&display=swap"
        rel="stylesheet">
</head>

<body>
    <div id="overlay">
        <h2>üöÖ Vivid Nature Tracker</h2>
        <div id="status" style="font-size: 0.9rem; color: #aaa;">‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏ß‡∏î‡∏•‡πâ‡∏≠‡∏°‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>
        <div style="margin-top: 10px; font-size: 0.9rem;">‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á: <span id="percent"
                style="color: #10b981; font-weight: bold; font-size: 1.1rem;">0</span>%</div>
    </div>

    <div id="footer">Generated by <strong>Antigravity Oracle</strong> | <em>Vivid Nature (Optimized) Edition</em></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <script>
        // 1. SCENE SETUP (MAX PERFORMANCE - BasicMaterials Only)
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue
        scene.fog = new THREE.Fog(0x87ceeb, 20, 500); // Gives depth, hides rendering limits

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1); // Force 1.0 (No retina scaling lag)
        renderer.shadowMap.enabled = false; // NO SHADOWS
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false;
        controls.maxPolarAngle = Math.PI / 2 - 0.01; // Block looking below ground

        // NO LIGHTS ADDED. Everything uses MeshBasicMaterial for 60FPS guarantees.

        // 2. ENVIRONMENT CREATION

        // Grass Ground (Base)
        const groundGeo = new THREE.PlaneGeometry(2500, 2500);
        const groundMat = new THREE.MeshBasicMaterial({ color: 0x4d7c2b });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0; // Strict Y=0 floor
        scene.add(ground);

        // River (Winding wide curve)
        const riverGeo = new THREE.PlaneGeometry(2500, 30);
        const riverMat = new THREE.MeshBasicMaterial({ color: 0x3b82f6 }); // River blue
        const river = new THREE.Mesh(riverGeo, riverMat);
        river.rotation.x = -Math.PI / 2;
        river.rotation.z = Math.PI / 4;
        river.position.set(0, 0.02, 0); // Slightly above ground
        scene.add(river);

        // Dirt Patches (Instanced Planes for efficiency)
        const patchCount = 300;
        const patchGeo = new THREE.CircleGeometry(10, 8);
        const patchMat = new THREE.MeshBasicMaterial({ color: 0x6e4e2c }); // Brown dirt
        const patchMesh = new THREE.InstancedMesh(patchGeo, patchMat, patchCount);

        const dummy = new THREE.Object3D();
        for (let i = 0; i < patchCount; i++) {
            dummy.position.set((Math.random() - 0.5) * 1200, 0.01, (Math.random() - 0.5) * 1200);
            dummy.rotation.x = -Math.PI / 2;
            dummy.scale.set(1 + Math.random(), 1 + Math.random(), 1);
            dummy.updateMatrix();
            patchMesh.setMatrixAt(i, dummy.matrix);
        }
        scene.add(patchMesh);

        // Trees (Instanced Cones & Cylinders)
        const treeCount = 2000;
        const leavesGeo = new THREE.ConeGeometry(2, 6, 5); // Low poly cone
        const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 3, 5);
        const leavesMat = new THREE.MeshBasicMaterial({ color: 0x2d5a1e }); // Darker green
        const trunkMat = new THREE.MeshBasicMaterial({ color: 0x4a341e }); // Brown

        const treesMesh = new THREE.InstancedMesh(leavesGeo, leavesMat, treeCount);
        const trunksMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);

        let treesAdded = 0;
        while (treesAdded < treeCount) {
            const x = (Math.random() - 0.5) * 1500;
            const z = (Math.random() - 0.5) * 1500;
            // Keep clear of the center track mostly (simple heuristic)
            if (Math.abs(x) < 20 && Math.abs(z) < 20) continue;

            const scale = 0.5 + Math.random() * 0.8;

            dummy.position.set(x, 1.5 * scale, z); // Trunk base
            dummy.scale.set(scale, scale, scale);
            dummy.updateMatrix();
            trunksMesh.setMatrixAt(treesAdded, dummy.matrix);

            dummy.position.set(x, 4.5 * scale, z); // Leaves top
            dummy.updateMatrix();
            treesMesh.setMatrixAt(treesAdded, dummy.matrix);

            treesAdded++;
        }
        scene.add(treesMesh);
        scene.add(trunksMesh);

        // Animals (Instanced simple boxes like Minecraft sheep/cows)
        const animalCount = 150;
        const animalGeo = new THREE.BoxGeometry(1.5, 1, 2.5);
        const animalMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White sheep/cow body
        const animalMesh = new THREE.InstancedMesh(animalGeo, animalMat, animalCount);

        for (let i = 0; i < animalCount; i++) {
            dummy.position.set((Math.random() - 0.5) * 400, 0.5, (Math.random() - 0.5) * 400); // Cluster near track
            dummy.rotation.y = Math.random() * Math.PI * 2;
            dummy.scale.set(1, 1, 1);
            dummy.updateMatrix();
            animalMesh.setMatrixAt(i, dummy.matrix);
        }
        scene.add(animalMesh);

        // Birds (Instanced V shapes flapping)
        const birdCount = 100;
        const birdGeo = new THREE.PlaneGeometry(0.8, 0.4); // Very simple wings
        const birdMat = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });
        const birdMesh = new THREE.InstancedMesh(birdGeo, birdMat, birdCount);

        const birdData = []; // Store flapping state

        for (let i = 0; i < birdCount; i++) {
            const bx = (Math.random() - 0.5) * 600;
            const by = 20 + Math.random() * 30; // High in sky
            const bz = (Math.random() - 0.5) * 600;

            dummy.position.set(bx, by, bz);
            dummy.rotation.x = Math.PI / 2; // Flat 
            dummy.updateMatrix();
            birdMesh.setMatrixAt(i, dummy.matrix);

            birdData.push({ x: bx, y: by, z: bz, speed: 0.2 + Math.random() * 0.2, phase: Math.random() * 10 });
        }
        scene.add(birdMesh);

        // Clouds (Simple fluffy clusters)
        const cloudGroup = new THREE.Group();
        const cloudGeo = new THREE.IcosahedronGeometry(10, 0); // Low poly fluff
        const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

        for (let i = 0; i < 60; i++) {
            const cx = (Math.random() - 0.5) * 1000;
            const cy = 60 + Math.random() * 40;
            const cz = (Math.random() - 0.5) * 1000;

            // Cluster of 3 for one cloud
            for (let j = 0; j < 3; j++) {
                const puff = new THREE.Mesh(cloudGeo, cloudMat);
                puff.position.set(cx + (Math.random() - 0.5) * 15, cy + (Math.random() - 0.5) * 5, cz + (Math.random() - 0.5) * 15);
                puff.scale.set(1 + Math.random(), 0.5 + Math.random() * 0.5, 1 + Math.random());
                cloudGroup.add(puff);
            }
        }
        scene.add(cloudGroup);


        // 3. LOW-POLY TRAIN
        function createTrain() {
            const trainObj = new THREE.Group();
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const stripeMat = new THREE.MeshBasicMaterial({ color: 0x3b82f6 });
            const glassMat = new THREE.MeshBasicMaterial({ color: 0x111111 });

            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 2.5, 8), bodyMat);
            body.position.y = 1.25; // Local offset
            trainObj.add(body);

            const nose = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 1, 3, 8), bodyMat);
            nose.rotation.x = Math.PI / 2;
            nose.position.set(0, 1.25, 5.5);
            trainObj.add(nose);

            const stripe = new THREE.Mesh(new THREE.BoxGeometry(2.05, 0.3, 10.5), stripeMat);
            stripe.position.set(0, 0.8, 1);
            trainObj.add(stripe);

            const win = new THREE.Mesh(new THREE.BoxGeometry(2.05, 0.8, 6), glassMat);
            win.position.set(0, 1.8, 0);
            trainObj.add(win);

            const frontWin = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 1.5), glassMat);
            frontWin.rotation.x = -Math.PI / 8;
            frontWin.position.set(0, 1.9, 4.2);
            trainObj.add(frontWin);

            return trainObj;
        }

        const train = createTrain();
        scene.add(train);

        // 4. DATA PARSING & TRACK
        let curve = null;
        let vecs = [];
        let animationProgress = 0;
        const animationSpeed = 0.0008;

        const csvUrl = "./travel-phitsanulok.csv";

        Papa.parse(csvUrl, {
            download: true,
            header: true,
            skipEmptyLines: true,
            complete: function (results) {
                document.getElementById('status').innerHTML = '<span style="color:#10b981">‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô</span>';
                processData(results.data);
            }
        });

        function processData(data) {
            const sorted = data.sort((a, b) => new Date(a.updated) - new Date(b.updated));
            let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
            sorted.forEach(row => {
                const lat = parseFloat(row.lat);
                const lon = parseFloat(row.lon);
                if (!isNaN(lat) && !isNaN(lon)) {
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                    if (lon < minLon) minLon = lon;
                    if (lon > maxLon) maxLon = lon;
                }
            });

            const centerLat = (minLat + maxLat) / 2;
            const centerLon = (minLon + maxLon) / 2;
            const scale = 40;

            sorted.forEach(row => {
                const lat = parseFloat(row.lat);
                const lon = parseFloat(row.lon);

                if (!isNaN(lat) && !isNaN(lon)) {
                    const x = (lon - centerLon) * scale;
                    const z = -(lat - centerLat) * scale;
                    // FORCE Y TO BE EXACTLY 0 
                    const y = 0;
                    const vec = new THREE.Vector3(x, y, z);

                    if (vecs.length > 0) {
                        if (vec.distanceTo(vecs[vecs.length - 1]) < 0.5) return;
                    }
                    vecs.push(vec);
                }
            });

            if (vecs.length < 2) return;

            curve = new THREE.CatmullRomCurve3(vecs);

            // Simple line track (fastest to render)
            const trackPoints = curve.getPoints(vecs.length * 2);
            const trackGeo = new THREE.BufferGeometry().setFromPoints(trackPoints);
            const trackMat = new THREE.LineBasicMaterial({ color: 0x999999, linewidth: 3 });
            const track = new THREE.Line(trackGeo, trackMat);
            scene.add(track);

            // Track Ties (Sleeper blocks for realism but extremely lightweight)
            const tieGeo = new THREE.BoxGeometry(2.5, 0.1, 0.3);
            const tieMat = new THREE.MeshBasicMaterial({ color: 0x888888 });
            const tieMesh = new THREE.InstancedMesh(tieGeo, tieMat, trackPoints.length / 2);

            for (let i = 0, j = 0; i < trackPoints.length; i += 2, j++) {
                if (i + 1 < trackPoints.length) {
                    const pt = trackPoints[i];
                    const nextpt = trackPoints[i + 1];
                    const dir = nextpt.clone().sub(pt).normalize();

                    dummy.position.copy(pt);
                    dummy.position.y = 0.05; // Slightly above ground
                    dummy.lookAt(pt.clone().add(dir));
                    dummy.updateMatrix();
                    tieMesh.setMatrixAt(j, dummy.matrix);
                }
            }
            scene.add(tieMesh);

            // Start/End Markers
            const markerGeo = new THREE.CircleGeometry(3, 16);

            const startMark = new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0x10b981 }));
            startMark.rotation.x = -Math.PI / 2;
            startMark.position.copy(vecs[0]);
            startMark.position.y = 0.06;
            scene.add(startMark);

            const endMark = new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0xef4444 }));
            endMark.rotation.x = -Math.PI / 2;
            endMark.position.copy(vecs[vecs.length - 1]);
            endMark.position.y = 0.06;
            scene.add(endMark);

            const startPt = curve.getPointAt(0);
            camera.position.set(startPt.x - 15, 3, startPt.z - 15);
            controls.target.copy(startPt);

            animate();
        }

        const percentSpan = document.getElementById('percent');
        let isPaused = false;
        let clock = new THREE.Clock(); // For bird animation

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            if (curve && !isPaused) {
                animationProgress += animationSpeed;

                if (animationProgress >= 1) {
                    animationProgress = 1;
                    isPaused = true;
                    percentSpan.innerText = "‡∏ñ‡∏∂‡∏á‡∏ó‡∏µ‡πà‡∏´‡∏°‡∏≤‡∏¢";
                    percentSpan.style.color = "#ef4444";
                    setTimeout(() => {
                        animationProgress = 0;
                        isPaused = false;
                        percentSpan.style.color = "#10b981";
                    }, 3000);
                }

                // --------- STRICT PHYSICS LOCK ---------
                // Place train EXACTLY on path
                const pos = curve.getPointAt(animationProgress);
                const tangent = curve.getTangentAt(animationProgress).normalize();

                train.position.set(pos.x, 0, pos.z); // Force Y=0 ALWAYS

                // Look along path (locked to Y=0 plane)
                const lookTarget = pos.clone().add(tangent);
                lookTarget.y = 0; // Prevent looking up/down
                train.lookAt(lookTarget);

                controls.target.set(pos.x, 0, pos.z);

                // Eye-level cinematic tracking camera (Never floats high)
                const followDistance = 14;
                const cameraHeight = 2.5; // Eye Level

                // Keep camera locked behind the train smoothly but strictly
                camera.position.set(
                    pos.x - (tangent.x * followDistance),
                    cameraHeight,
                    pos.z - (tangent.z * followDistance)
                );

                // Look directly at train body
                camera.lookAt(pos.x, 1.25, pos.z);

                if (!isPaused) {
                    percentSpan.innerText = Math.floor(animationProgress * 100);
                }
            }

            // Animate environment safely
            cloudGroup.rotation.y += 0.0005; // Slow ambient clouds rotation

            // Animate Birds (Flapping and moving forward)
            for (let i = 0; i < birdCount; i++) {
                const b = birdData[i];
                b.z -= b.speed;
                if (b.z < -400) b.z = 400; // recycle

                dummy.position.set(b.x, b.y, b.z);

                // Flap wings (oscillate scale/rotation)
                dummy.rotation.x = Math.PI / 2 + Math.sin(time * 15 + b.phase) * 0.2;
                dummy.scale.set(1, 1, 1 - Math.abs(Math.sin(time * 15 + b.phase)) * 0.5);

                dummy.updateMatrix();
                birdMesh.setMatrixAt(i, dummy.matrix);
            }
            birdMesh.instanceMatrix.needsUpdate = true;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>