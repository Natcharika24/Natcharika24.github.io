<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Train Tracker | Fast & Beautiful</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87ceeb;
            font-family: 'Outfit', 'Prompt', sans-serif;
            color: white;
        }

        #overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(20, 30, 40, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #10b981;
            backdrop-filter: blur(5px);
        }

        h2 {
            margin: 0 0 10px 0;
            color: #10b981;
            font-family: 'Outfit', sans-serif;
        }

        #footer {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            z-index: 10;
            font-size: 0.85rem;
            color: #333;
            font-family: 'Outfit';
            pointer-events: none;
        }

        #infoBox {
            display: none;
            position: absolute;
            background: rgba(30, 30, 30, 0.9);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            pointer-events: none;
            z-index: 20;
            transform: translate(15px, -50%);
        }
    </style>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&family=Prompt:wght@300;400;500&display=swap"
        rel="stylesheet">
</head>

<body>
    <div id="overlay">
        <h2>üöÇ Modern 3D Train</h2>
        <div id="status">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á...</div>
        <div id="progress" style="margin-top: 10px; color: #eee;">‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á: <span id="percent"
                style="color: #10b981; font-weight: bold;">0</span>%</div>
        <div style="margin-top: 15px; font-size: 0.8rem; color: #ddd;">* ‡∏•‡∏∑‡πà‡∏ô‡πÑ‡∏´‡∏• ‡πÑ‡∏°‡πà‡∏Ñ‡πâ‡∏≤‡∏á (Low-Poly Mod)<br>* ‡∏°‡∏µ‡∏ó‡πâ‡∏≠‡∏á‡∏ü‡πâ‡∏≤
            ‡∏Å‡πâ‡∏≠‡∏ô‡πÄ‡∏°‡∏Ü ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏ç‡πâ‡∏≤</div>
    </div>

    <div id="footer">Generated by <strong>Antigravity Oracle</strong> | <em>Fast & Beautiful Edition</em></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <script>
        // Setup Three.js Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.0035); // Fog for depth

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1500);

        // Optimize WebGLRenderer for speed
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.25)); // Keep resolution capped
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap; // Fastest shadow type
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.01;

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xfff5e6, 0.85); // Warm sun
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024; // Balanced res shadows for speed
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.near = 10;
        dirLight.shadow.camera.far = 600;
        dirLight.shadow.camera.left = -150;
        dirLight.shadow.camera.right = 150;
        dirLight.shadow.camera.top = 150;
        dirLight.shadow.camera.bottom = -150;
        scene.add(dirLight);

        // Ground (Grass)
        const groundGeo = new THREE.PlaneGeometry(3000, 3000);
        const groundMat = new THREE.MeshLambertMaterial({ color: 0x4d7c2b }); // Simple green shading
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        // Clouds (Low Poly Spheres Group)
        const cloudGroup = new THREE.Group();
        const cloudGeo = new THREE.DodecahedronGeometry(6, 0); // Very Low poly
        const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff });

        for (let i = 0; i < 70; i++) {
            const cloud = new THREE.Mesh(cloudGeo, cloudMat);
            cloud.position.set(
                (Math.random() - 0.5) * 1200,
                40 + Math.random() * 80,
                (Math.random() - 0.5) * 1200
            );
            cloud.scale.set(1 + Math.random() * 2, 0.5 + Math.random() * 0.5, 1 + Math.random() * 2);
            cloud.rotation.y = Math.random() * Math.PI;
            cloudGroup.add(cloud);
        }
        scene.add(cloudGroup);

        // Low-Poly Modern Train Maker
        function createTrain() {
            const trainObj = new THREE.Group();

            const bodyMat = new THREE.MeshLambertMaterial({ color: 0xf3f4f6 }); // White body
            const stripeMat = new THREE.MeshLambertMaterial({ color: 0x3b82f6 }); // Blue stripe
            const glassMat = new THREE.MeshLambertMaterial({ color: 0x111827 }); // Dark window

            // Main body cabin
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.6, 3.2, 10), bodyMat);
            body.position.y = 1.8;
            body.castShadow = true;
            trainObj.add(body);

            // Nose Cone
            const noseGeo = new THREE.CylinderGeometry(0.5, 1.3, 4, 16);
            const nose = new THREE.Mesh(noseGeo, bodyMat);
            nose.rotation.x = Math.PI / 2;
            nose.position.set(0, 1.8, 6.5);
            nose.scale.set(1, 1, 0.75);
            nose.castShadow = true;
            trainObj.add(nose);

            // Side Stripe
            const stripeGeo = new THREE.BoxGeometry(2.65, 0.4, 9.8);
            const stripe = new THREE.Mesh(stripeGeo, stripeMat);
            stripe.position.set(0, 1.2, 0);
            trainObj.add(stripe);

            // Windows Strip
            const winGeo = new THREE.BoxGeometry(2.7, 1.2, 8);
            const windowObj = new THREE.Mesh(winGeo, glassMat);
            windowObj.position.set(0, 2.3, 0);
            trainObj.add(windowObj);

            // Windshield
            const windGeo = new THREE.PlaneGeometry(1.5, 1.2);
            const windshield = new THREE.Mesh(windGeo, glassMat);
            windshield.rotation.x = -Math.PI / 4;
            windshield.position.set(0, 2.7, 5.0);
            trainObj.add(windshield);

            // Engine Wheels (Hidden inside box base for performance)
            const bogieGeo = new THREE.BoxGeometry(2.4, 0.8, 3.5);
            const bogieMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
            const bogie1 = new THREE.Mesh(bogieGeo, bogieMat);
            bogie1.position.set(0, 0.4, 3);
            bogie1.castShadow = true;
            trainObj.add(bogie1);

            const bogie2 = new THREE.Mesh(bogieGeo, bogieMat);
            bogie2.position.set(0, 0.4, -3);
            bogie2.castShadow = true;
            trainObj.add(bogie2);

            return trainObj;
        }

        const train = createTrain();
        scene.add(train);

        // Data Variables
        let curve = null;
        let vecs = [];
        let animationProgress = 0;
        const animationSpeed = 0.0006;

        // Dynamic Start/End Markers
        let startMark, endMark;

        const csvUrl = "./travel-phitsanulok.csv";

        Papa.parse(csvUrl, {
            download: true,
            header: true,
            skipEmptyLines: true,
            complete: function (results) {
                document.getElementById('status').innerHTML = '<span style="color:#10b981">‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏•‡πâ‡∏ß!</span>';
                processData(results.data);
            }
        });

        function processData(data) {
            const sorted = data.sort((a, b) => new Date(a.updated) - new Date(b.updated));

            let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
            sorted.forEach(row => {
                const lat = parseFloat(row.lat);
                const lon = parseFloat(row.lon);
                if (!isNaN(lat) && !isNaN(lon)) {
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                    if (lon < minLon) minLon = lon;
                    if (lon > maxLon) maxLon = lon;
                }
            });

            const centerLat = (minLat + maxLat) / 2;
            const centerLon = (minLon + maxLon) / 2;
            const scale = 50; // Smaller scale keeping points closer for tighter visual

            sorted.forEach(row => {
                const lat = parseFloat(row.lat);
                const lon = parseFloat(row.lon);

                if (!isNaN(lat) && !isNaN(lon)) {
                    const x = (lon - centerLon) * scale;
                    const z = -(lat - centerLat) * scale;
                    const y = 0.1; // Ground level
                    const vec = new THREE.Vector3(x, y, z);

                    if (vecs.length > 0) {
                        const lastVec = vecs[vecs.length - 1];
                        if (vec.distanceTo(lastVec) < 0.5) return;
                    }
                    vecs.push(vec);
                }
            });

            if (vecs.length < 2) return;

            curve = new THREE.CatmullRomCurve3(vecs);

            // Track Line (Extremely lightweight TubeGeometry)
            const trackPoints = curve.getPoints(vecs.length * 6);
            const trackGeo = new THREE.TubeGeometry(curve, trackPoints.length, 0.4, 4, false); // Low sides (4) for speed
            const trackMat = new THREE.MeshLambertMaterial({ color: 0x999999 });
            const track = new THREE.Mesh(trackGeo, trackMat);
            track.position.y = -0.2;
            scene.add(track);

            // Start/End Geo
            const nodeGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 16);

            startMark = new THREE.Mesh(nodeGeo, new THREE.MeshLambertMaterial({ color: 0x10b981 })); // Green Start
            startMark.position.copy(vecs[0]);
            scene.add(startMark);

            endMark = new THREE.Mesh(nodeGeo, new THREE.MeshLambertMaterial({ color: 0xef4444 })); // Red End
            endMark.position.copy(vecs[vecs.length - 1]);
            scene.add(endMark);

            // Initial Camera look
            const startPt = curve.getPointAt(0);
            camera.position.set(startPt.x + 20, startPt.y + 12, startPt.z + 15);
            controls.target.copy(startPt);

            animate();
        }

        const percentSpan = document.getElementById('percent');
        let isPaused = false;

        function animate() {
            requestAnimationFrame(animate);

            if (curve && !isPaused) {
                animationProgress += animationSpeed;

                if (animationProgress >= 1) {
                    animationProgress = 1;
                    isPaused = true;

                    percentSpan.innerText = "‡∏ñ‡∏∂‡∏á‡∏à‡∏∏‡∏î‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ (Phitsanulok)";
                    percentSpan.style.color = "#ef4444";

                    setTimeout(() => {
                        animationProgress = 0;
                        isPaused = false;
                        percentSpan.style.color = "#10b981";
                    }, 4000);
                }

                const pos = curve.getPointAt(animationProgress);
                const tangent = curve.getTangentAt(animationProgress).normalize();

                train.position.copy(pos);
                // Orient train exactly along path
                const lookAtPt = pos.clone().add(tangent);
                train.lookAt(lookAtPt);

                // Smoothly pull Orbit target to train
                controls.target.lerp(pos, 0.05);

                // Drift camera behind training pulling back gracefully
                const cameraOffsetTarget = pos.clone().add(new THREE.Vector3(15, 12, 15));
                camera.position.lerp(cameraOffsetTarget, 0.02);

                if (!isPaused) {
                    percentSpan.innerText = Math.floor(animationProgress * 100);
                }
            }

            // Slowly animate clouds rotating in the sky for life
            cloudGroup.rotation.y += 0.0002;

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>