<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra-Fast 3D Train Tracker</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87ceeb;
            font-family: 'Outfit', 'Prompt', sans-serif;
            color: white;
        }

        #overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #10b981;
        }

        h2 {
            margin: 0 0 5px 0;
            color: #10b981;
            font-family: 'Outfit', sans-serif;
            font-size: 1.2rem;
        }

        #footer {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            z-index: 10;
            font-size: 0.8rem;
            color: #222;
            font-family: 'Outfit';
            pointer-events: none;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&family=Prompt:wght@400&display=swap"
        rel="stylesheet">
</head>

<body>
    <div id="overlay">
        <h2>ðŸš… Ultra-Fast Tracker</h2>
        <div id="status" style="font-size: 0.9rem; color: #aaa;">à¹‚à¸«à¸¥à¸”à¸‚à¹‰à¸­à¸¡à¸¹à¸¥...</div>
        <div style="margin-top: 10px; font-size: 0.9rem;">à¸£à¸°à¸¢à¸°à¸—à¸²à¸‡: <span id="percent"
                style="color: #10b981; font-weight: bold; font-size: 1.1rem;">0</span>%</div>
    </div>

    <div id="footer">Generated by <strong>Antigravity Oracle</strong> | <em>Ultra-Performance Edition</em></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <script>
        // 1. SCENE SETUP (MAX PERFORMANCE)
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue
        scene.fog = new THREE.Fog(0x87ceeb, 100, 800); // Simple linear fog is faster

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);

        // Disable antialiasing and shadowmaps completely for maximum speed
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1); // Force 1.0 pixel ratio (no retina scaling lag)
        renderer.shadowMap.enabled = false; // NO SHADOWS
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false; // Disable damping physics for speed
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // 2. NO LIGHTS NEEDED (Using Basic Materials)
        // Basic Materials ignore light and are fully bright all the time. Extremely fast.

        // 3. GROUND (Flat green plane at Y=0)
        const groundGeo = new THREE.PlaneGeometry(2000, 2000);
        const groundMat = new THREE.MeshBasicMaterial({ color: 0x4d7c2b }); // Green grass
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        scene.add(ground);

        // 4. CLOUDS (Very few, basic 2D circles or simple planes to save polygons)
        const cloudGroup = new THREE.Group();
        const cloudGeo = new THREE.PlaneGeometry(30, 15);
        const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, side: THREE.DoubleSide });

        for (let i = 0; i < 30; i++) {
            const cloud = new THREE.Mesh(cloudGeo, cloudMat);
            cloud.position.set(
                (Math.random() - 0.5) * 800,
                50 + Math.random() * 50,
                (Math.random() - 0.5) * 800
            );
            // Always face camera horizontally
            cloud.rotation.y = Math.random() * Math.PI;
            cloudGroup.add(cloud);
        }
        scene.add(cloudGroup);

        // 5. TRAIN (Ultra-simple boxes)
        function createTrain() {
            const trainObj = new THREE.Group();
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White
            const stripeMat = new THREE.MeshBasicMaterial({ color: 0x3b82f6 }); // Blue
            const glassMat = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Black windows

            // Body
            const bodyGeo = new THREE.BoxGeometry(2, 2.5, 8);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.25; // Directly on ground
            trainObj.add(body);

            // Stripe
            const stripe = new THREE.Mesh(new THREE.BoxGeometry(2.05, 0.3, 8.01), stripeMat);
            stripe.position.y = 0.8;
            trainObj.add(stripe);

            // Window strip
            const win = new THREE.Mesh(new THREE.BoxGeometry(2.05, 0.8, 6), glassMat);
            win.position.set(0, 1.8, 0);
            trainObj.add(win);

            return trainObj;
        }

        const train = createTrain();
        scene.add(train);

        // 6. DATA & PATH
        let curve = null;
        let vecs = [];
        let animationProgress = 0;
        const animationSpeed = 0.001; // Faster

        const csvUrl = "./travel-phitsanulok.csv";

        Papa.parse(csvUrl, {
            download: true,
            header: true,
            skipEmptyLines: true,
            complete: function (results) {
                document.getElementById('status').innerHTML = '<span style="color:#10b981">à¸£à¸°à¸šà¸šà¸žà¸£à¹‰à¸­à¸¡à¸—à¸³à¸‡à¸²à¸™ (à¹‚à¸«à¸¡à¸”à¸¥à¸·à¹ˆà¸™à¹„à¸«à¸¥à¸ªà¸¹à¸‡à¸ªà¸¸à¸”)</span>';
                processData(results.data);
            }
        });

        function processData(data) {
            const sorted = data.sort((a, b) => new Date(a.updated) - new Date(b.updated));
            let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
            sorted.forEach(row => {
                const lat = parseFloat(row.lat);
                const lon = parseFloat(row.lon);
                if (!isNaN(lat) && !isNaN(lon)) {
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                    if (lon < minLon) minLon = lon;
                    if (lon > maxLon) maxLon = lon;
                }
            });

            const centerLat = (minLat + maxLat) / 2;
            const centerLon = (minLon + maxLon) / 2;
            const scale = 40; // Smaller track

            sorted.forEach(row => {
                const lat = parseFloat(row.lat);
                const lon = parseFloat(row.lon);

                if (!isNaN(lat) && !isNaN(lon)) {
                    const x = (lon - centerLon) * scale;
                    const z = -(lat - centerLat) * scale;
                    const y = 0.01; // Barely above ground to prevent Z-fighting
                    const vec = new THREE.Vector3(x, y, z);

                    if (vecs.length > 0) {
                        if (vec.distanceTo(vecs[vecs.length - 1]) < 0.5) return;
                    }
                    vecs.push(vec);
                }
            });

            if (vecs.length < 2) return;

            curve = new THREE.CatmullRomCurve3(vecs);

            // Simple line track (fastest to render)
            const trackPoints = curve.getPoints(vecs.length * 2);
            const trackGeo = new THREE.BufferGeometry().setFromPoints(trackPoints);
            const trackMat = new THREE.LineBasicMaterial({ color: 0x999999, linewidth: 2 });
            const track = new THREE.Line(trackGeo, trackMat);
            scene.add(track);

            // Flat Circle Markers for Start/End
            const markerGeo = new THREE.CircleGeometry(2, 16);

            const startMark = new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0x10b981 }));
            startMark.rotation.x = -Math.PI / 2;
            startMark.position.copy(vecs[0]);
            startMark.position.y = 0.05;
            scene.add(startMark);

            const endMark = new THREE.Mesh(markerGeo, new THREE.MeshBasicMaterial({ color: 0xef4444 }));
            endMark.rotation.x = -Math.PI / 2;
            endMark.position.copy(vecs[vecs.length - 1]);
            endMark.position.y = 0.05;
            scene.add(endMark);

            const startPt = curve.getPointAt(0);
            camera.position.set(startPt.x + 15, startPt.y + 10, startPt.z + 15);
            controls.target.copy(startPt);

            animate();
        }

        const percentSpan = document.getElementById('percent');
        let isPaused = false;

        function animate() {
            requestAnimationFrame(animate);

            if (curve && !isPaused) {
                animationProgress += animationSpeed;

                if (animationProgress >= 1) {
                    animationProgress = 1;
                    isPaused = true;
                    percentSpan.innerText = "à¸–à¸¶à¸‡à¸—à¸µà¹ˆà¸«à¸¡à¸²à¸¢";
                    percentSpan.style.color = "#ef4444";
                    setTimeout(() => {
                        animationProgress = 0;
                        isPaused = false;
                        percentSpan.style.color = "#10b981";
                    }, 3000);
                }

                // Place train EXACTLY on path
                const pos = curve.getPointAt(animationProgress);
                const tangent = curve.getTangentAt(animationProgress).normalize();

                train.position.copy(pos);
                train.position.y = 0; // Exactly on ground

                // Look along path
                train.lookAt(pos.clone().add(tangent));

                controls.target.copy(pos);

                // Simple camera follow
                camera.position.set(pos.x - (tangent.x * 15), pos.y + 10, pos.z - (tangent.z * 15));

                if (!isPaused) {
                    percentSpan.innerText = Math.floor(animationProgress * 100);
                }
            }

            // Make clouds face camera
            cloudGroup.children.forEach(c => c.lookAt(camera.position));

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>