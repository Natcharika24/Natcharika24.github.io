<!DOCTYPE html>
<html lang="th">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic 3D Train Tracker | Chiang Mai to Phitsanulok</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Outfit', 'Prompt', sans-serif;
            color: white;
        }

        #overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background: rgba(20, 30, 40, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #4ade80;
            backdrop-filter: blur(5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        h2 {
            margin: 0 0 10px 0;
            color: #4ade80;
            font-family: 'Outfit', sans-serif;
        }

        #footer {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            z-index: 10;
            font-size: 0.85rem;
            color: #333;
            font-family: 'Outfit';
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
        }
    </style>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&family=Prompt:wght@300;400;500&display=swap"
        rel="stylesheet">
</head>

<body>
    <div id="overlay">
        <h2>üöÇ Realistic 3D Express</h2>
        <div id="status">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á...</div>
        <div id="progress" style="margin-top: 10px; color: #ddd;">‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞: <span id="percent"
                style="color: #fff; font-weight: bold;">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏î‡∏¥‡∏ô‡∏ó‡∏≤‡∏á</span></div>
        <div style="margin-top: 15px; font-size: 0.8rem; color: #aaa;">* ‡∏ã‡∏π‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏£‡∏ñ‡πÑ‡∏ü‡πÅ‡∏•‡∏∞‡∏£‡∏≤‡∏á<br>*
            ‡∏´‡∏°‡∏∏‡∏ô‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏≠‡∏¥‡∏™‡∏£‡∏∞ 360¬∞</div>
    </div>

    <div id="footer">Generated by <strong>Antigravity Oracle</strong> | <em>"The Oracle Keeps the Human Human"</em>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <script>
        // Setup Three.js Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.02;

        // Lighting (Sunlight + Ambient)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xfff5b6, 1);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        dirLight.shadow.camera.left = -150;
        dirLight.shadow.camera.right = 150;
        dirLight.shadow.camera.top = 150;
        dirLight.shadow.camera.bottom = -150;
        scene.add(dirLight);

        // Environment Map (Ground)
        const groundGeo = new THREE.PlaneGeometry(1000, 1000);
        const groundMat = new THREE.MeshStandardMaterial({
            color: 0x2e8b57, // Sea green / Grass
            roughness: 0.8,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5;
        ground.receiveShadow = true;
        scene.add(ground);

        // Builder: Realistic Train
        function createTrain() {
            const trainGroup = new THREE.Group();

            // Materials
            const metalMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.4 });
            const paintMat = new THREE.MeshStandardMaterial({ color: 0xb91c1c, metalness: 0.3, roughness: 0.5 }); // Deep Red
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.9, roughness: 0.2 });

            // Boiler (Cylinder)
            const boilerGeo = new THREE.CylinderGeometry(1.2, 1.2, 5, 32);
            const boiler = new THREE.Mesh(boilerGeo, metalMat);
            boiler.rotation.x = Math.PI / 2;
            boiler.position.set(0, 1.8, 1);
            boiler.castShadow = true;
            trainGroup.add(boiler);

            // Cabin (Box)
            const cabinGeo = new THREE.BoxGeometry(2.8, 3.5, 2.5);
            const cabin = new THREE.Mesh(cabinGeo, paintMat);
            cabin.position.set(0, 2.2, -2);
            cabin.castShadow = true;
            trainGroup.add(cabin);

            // Cabin Roof
            const roofGeo = new THREE.BoxGeometry(3.2, 0.4, 3);
            const roof = new THREE.Mesh(roofGeo, metalMat);
            roof.position.set(0, 4.1, -2);
            roof.castShadow = true;
            trainGroup.add(roof);

            // Funnel
            const funnelGeo = new THREE.CylinderGeometry(0.5, 0.3, 1.5, 16);
            const funnel = new THREE.Mesh(funnelGeo, goldMat);
            funnel.position.set(0, 3.2, 2.5);
            funnel.castShadow = true;
            trainGroup.add(funnel);

            // Base chassis
            const chassisGeo = new THREE.BoxGeometry(2.6, 0.5, 7.5);
            const chassis = new THREE.Mesh(chassisGeo, metalMat);
            chassis.position.set(0, 0.5, -0.2);
            chassis.castShadow = true;
            trainGroup.add(chassis);

            // Cowcatcher (Front slope)
            const cowcatcherGeo = new THREE.CylinderGeometry(1.2, 1.5, 1, 3);
            const cowcatcher = new THREE.Mesh(cowcatcherGeo, metalMat);
            cowcatcher.rotation.x = Math.PI / 2;
            cowcatcher.rotation.y = Math.PI;
            cowcatcher.position.set(0, 0.5, 4);
            cowcatcher.castShadow = true;
            trainGroup.add(cowcatcher);

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.4, 24);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1 });
            const wheelPositions = [
                [-1.4, -2], [1.4, -2], // Back
                [-1.4, 0], [1.4, 0],   // Middle
                [-1.4, 2], [1.4, 2]    // Front
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos[0], 0.8, pos[1]);
                wheel.castShadow = true;
                trainGroup.add(wheel);
            });

            return trainGroup;
        }

        const train = createTrain();
        scene.add(train);

        // Data Variables
        let curve = null;
        let vecs = [];
        let animationProgress = 0;
        const animationSpeed = 0.0004;

        // Fetch Data
        const csvUrl = "./travel-phitsanulok.csv";

        Papa.parse(csvUrl, {
            download: true,
            header: true,
            skipEmptyLines: true,
            complete: function (results) {
                document.getElementById('status').innerHTML = '<span style="color:#4ade80">‡∏£‡∏∞‡∏ö‡∏ö‡∏£‡∏≤‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô!</span>';
                processData(results.data);
            }
        });

        function processData(data) {
            const sorted = data.sort((a, b) => new Date(a.updated) - new Date(b.updated));

            // Calculate center
            let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
            sorted.forEach(row => {
                const lat = parseFloat(row.lat);
                const lon = parseFloat(row.lon);
                if (!isNaN(lat) && !isNaN(lon)) {
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                    if (lon < minLon) minLon = lon;
                    if (lon > maxLon) maxLon = lon;
                }
            });

            const centerLat = (minLat + maxLat) / 2;
            const centerLon = (minLon + maxLon) / 2;
            const scale = 60;

            sorted.forEach(row => {
                const lat = parseFloat(row.lat);
                const lon = parseFloat(row.lon);
                if (!isNaN(lat) && !isNaN(lon)) {
                    const x = (lon - centerLon) * scale;
                    const z = -(lat - centerLat) * scale;
                    const y = 0;
                    const vec = new THREE.Vector3(x, y, z);

                    if (vecs.length > 0) {
                        if (vec.distanceTo(vecs[vecs.length - 1]) < 0.5) return;
                    }
                    vecs.push(vec);
                }
            });

            if (vecs.length < 2) return;

            curve = new THREE.CatmullRomCurve3(vecs);

            // Builder: Realistic Track
            buildTracks(curve);

            // Add Scenery (Simple Trees)
            addScenery();

            // Init Camera
            const startPt = curve.getPointAt(0);
            camera.position.set(startPt.x + 15, startPt.y + 10, startPt.z - 20);
            controls.target.copy(startPt);

            animate();
        }

        function buildTracks(pathCurve) {
            const trackPoints = pathCurve.getPoints(vecs.length * 15);

            // Rails (Extrude Geometry)
            const railShape = new THREE.Shape();
            railShape.moveTo(-0.1, 0);
            railShape.lineTo(0.1, 0);
            railShape.lineTo(0.1, 0.2);
            railShape.lineTo(-0.1, 0.2);
            railShape.lineTo(-0.1, 0);

            const extrudeSettings = { steps: trackPoints.length, bevelEnabled: false, extrudePath: pathCurve };
            const railGeo = new THREE.ExtrudeGeometry(railShape, extrudeSettings);
            const railMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9, roughness: 0.3 });

            const leftRail = new THREE.Mesh(railGeo, railMat);
            const rightRail = new THREE.Mesh(railGeo, railMat);

            // Move rails apart
            leftRail.position.y = 0.1;
            rightRail.position.y = 0.1;

            scene.add(leftRail);
            scene.add(rightRail);

            // Since ExtrudeGeometry follows the center, we need to manually offset the vertices to create two parallel rails.
            // A simpler approach for parallel rails is just 2 tubes slightly offset or modifying the shape.
            // For stability without matrix math on curves: we'll use TubeGeometry for rails instead.
            scene.remove(leftRail);
            scene.remove(rightRail);

            const baseCurveGeo = new THREE.TubeGeometry(pathCurve, trackPoints.length, 0.15, 8, false);
            const rail1 = new THREE.Mesh(baseCurveGeo, railMat);
            const rail2 = new THREE.Mesh(baseCurveGeo, railMat);

            // Sleepers (Wooden ties)
            const sleeperGeo = new THREE.BoxGeometry(3.5, 0.2, 0.6);
            const sleeperMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 });

            for (let i = 0; i < trackPoints.length; i += 2) {
                const pt = trackPoints[i];
                // get tangent to rotate sleeper perpendicularly
                const t = i / trackPoints.length;
                const tangent = pathCurve.getTangentAt(t).normalize();
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();

                const sleeper = new THREE.Mesh(sleeperGeo, sleeperMat);
                sleeper.position.copy(pt);
                sleeper.position.y = 0;

                // Align sleeper
                const lookTarget = pt.clone().add(normal);
                sleeper.lookAt(lookTarget);
                sleeper.receiveShadow = true;
                sleeper.castShadow = true;
                scene.add(sleeper);

                // Manually offset rails here since we have the normals
                if (i === 0) {
                    // This is complex to build a full custom mesh in one go without external libs,
                    // So we stick to a simplified single solid rail bed or rely on the visual of the sleepers.
                    // We will build two tube geometries.
                }
            }

            // We will just offset the entire tube group for left/right rails using a trick, or stick to one solid track bed to save performance.
            // Let's do a solid track bed above the sleepers
            const bedMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            const trackBed = new THREE.Mesh(new THREE.TubeGeometry(pathCurve, trackPoints.length, 1.2, 4, false), bedMat);
            trackBed.position.y = 0.15;
            trackBed.scale.y = 0.1; // flatten it
            scene.add(trackBed);

            // Add Start/End Flags
            const flagGeo = new THREE.CylinderGeometry(0.1, 0.1, 8);
            const startFlag = new THREE.Mesh(flagGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
            startFlag.position.copy(vecs[0]).add(new THREE.Vector3(3, 4, 0));

            const startBanner = new THREE.Mesh(new THREE.PlaneGeometry(3, 2), new THREE.MeshBasicMaterial({ color: 0x4ade80, side: THREE.DoubleSide }));
            startBanner.position.copy(startFlag.position).add(new THREE.Vector3(1.5, 3, 0));
            scene.add(startFlag); scene.add(startBanner);

            const endFlag = new THREE.Mesh(flagGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
            endFlag.position.copy(vecs[vecs.length - 1]).add(new THREE.Vector3(3, 4, 0));

            const endBanner = new THREE.Mesh(new THREE.PlaneGeometry(3, 2), new THREE.MeshBasicMaterial({ color: 0xef4444, side: THREE.DoubleSide }));
            endBanner.position.copy(endFlag.position).add(new THREE.Vector3(1.5, 3, 0));
            scene.add(endFlag); scene.add(endBanner);
        }

        // Add random trees around
        function addScenery() {
            const treeGeo = new THREE.ConeGeometry(2, 6, 8);
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.4, 2);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.9 });
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 1.0 });

            for (let i = 0; i < 150; i++) {
                const tree = new THREE.Group();
                const leaves = new THREE.Mesh(treeGeo, treeMat);
                leaves.position.y = 4;
                leaves.castShadow = true;
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 1;
                trunk.castShadow = true;
                tree.add(leaves);
                tree.add(trunk);

                // Random position
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;

                // Keep away from tracks (center 0,0 approx)
                if (Math.abs(x) > 10 || Math.abs(z) > 10) {
                    tree.position.set(x, 0, z);
                    scene.add(tree);
                }
            }
        }

        const percentSpan = document.getElementById('percent');
        let isPaused = false;

        function animate() {
            requestAnimationFrame(animate);

            if (curve && !isPaused) {
                animationProgress += animationSpeed;

                if (animationProgress >= 1) {
                    animationProgress = 1;
                    isPaused = true;
                    percentSpan.innerText = "‡∏ñ‡∏∂‡∏á‡∏ó‡∏µ‡πà‡∏´‡∏°‡∏≤‡∏¢ - ‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ‡∏û‡∏¥‡∏©‡∏ì‡∏∏‡πÇ‡∏•‡∏Å!";
                    percentSpan.style.color = "#4ade80";

                    setTimeout(() => {
                        animationProgress = 0;
                        isPaused = false;
                        percentSpan.style.color = "#fff";
                    }, 5000);
                }

                const pos = curve.getPointAt(animationProgress);
                const tangent = curve.getTangentAt(animationProgress).normalize();

                train.position.copy(pos);
                train.position.y = 0.5; // sit on track

                const lookAtPt = pos.clone().add(tangent);
                train.lookAt(lookAtPt);

                // Smooth Camera Follow - Cinematic Angle
                const cameraOffset = new THREE.Vector3(-15, 12, -15);
                cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.atan2(tangent.x, tangent.z));
                const cameraTargetPos = pos.clone().add(cameraOffset);

                camera.position.lerp(cameraTargetPos, 0.05);
                controls.target.lerp(pos.clone().add(new THREE.Vector3(0, 3, 0)), 0.08);

                if (!isPaused) {
                    percentSpan.innerText = Math.floor(animationProgress * 100) + " %";
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>